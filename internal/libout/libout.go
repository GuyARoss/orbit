// Copyright (c) 2021 Guy A. Ross
// This source code is licensed under the GNU GPLv3 found in the
// LICENSE file in the root directory of this source tree.
package libout

import (
	"context"
	"strings"

	"github.com/GuyARoss/orbit/internal/srcpack"
	webwrapper "github.com/GuyARoss/orbit/pkg/web_wrapper"
)

type BundleGroupOpts struct {
	PackageName   string
	BaseBundleOut string
	BundleMode    string
	PublicDir     string
}

type page struct {
	name        string
	bundleKey   string
	wrapVersion string
	filePath    string
}

type LiboutFile interface {
	Write(path string) error
}

// Libout represents autogenerated output created by the compiler
type Libout interface {
	TestFile(packageName string) (LiboutFile, error)
	HTTPFile(packageName string) (LiboutFile, error)
	EnvFile(*BundleGroup) (LiboutFile, error)
}

type FilePathOpts struct {
	TestFile string
	HTTPFile string
	EnvFile  string
}

type BundleGroup struct {
	*BundleGroupOpts

	pages            []*page
	componentBodyMap map[string][]string
}

func (opts *BundleGroup) WriteLibout(files Libout, fOpts *FilePathOpts) error {
	fns := []func() (LiboutFile, string, error){
		func() (LiboutFile, string, error) {
			f, err := files.EnvFile(opts)

			return f, fOpts.EnvFile, err
		},
		func() (LiboutFile, string, error) {
			f, err := files.HTTPFile(opts.PackageName)

			return f, fOpts.HTTPFile, err
		},
		func() (LiboutFile, string, error) {
			f, err := files.TestFile(opts.PackageName)

			return f, fOpts.TestFile, err
		},
	}

	// @@todo(guy): concurrent this
	for _, fn := range fns {
		fs, path, err := fn()
		if err != nil {
			return err
		}

		err = fs.Write(path)
		if err != nil {
			return err
		}
	}

	return nil
}

// parseVersionKey parses the version key and converts it to a valid key
func parseVersionKey(k string) string {
	f := strings.ReplaceAll(k, ".", "_")
	return strings.ReplaceAll(f, "-", "")
}

// AcceptComponents collects the required DOM elements and applies it to the component body map
func (l *BundleGroup) AcceptComponents(ctx context.Context, comps []*srcpack.Component, cacheOpts *webwrapper.CacheDOMOpts) {
	for _, c := range comps {
		v := parseVersionKey(c.WebWrapper.Version())

		l.pages = append(l.pages, &page{c.Name, c.BundleKey, v, c.OriginalFilePath()})
		l.componentBodyMap[v] = c.WebWrapper.RequiredBodyDOMElements(ctx, cacheOpts)
	}
}

func New(opts *BundleGroupOpts) *BundleGroup {
	return &BundleGroup{
		BundleGroupOpts: opts,

		pages:            make([]*page, 0),
		componentBodyMap: make(map[string][]string),
	}
}
