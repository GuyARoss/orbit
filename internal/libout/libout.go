// Copyright (c) 2021 Guy A. Ross
// This source code is licensed under the GNU GPLv3 found in the
// license file in the root directory of this source tree.

package libout

import (
	"context"
	"strings"

	"github.com/GuyARoss/orbit/internal/srcpack"
	"github.com/GuyARoss/orbit/pkg/embedutils"
	"github.com/GuyARoss/orbit/pkg/webwrap"
)

type BundleGroupOpts struct {
	PackageName   string
	BaseBundleOut string
	BundleMode    string
	PublicDir     string
	HotReloadPort int
}

type page struct {
	name             string
	bundleKey        string
	wrapVersion      string
	filePath         string
	isStaticResource bool
}

type pageList []*page

func (e pageList) Len() int {
	return len(e)
}

func (e pageList) Less(i, j int) bool {
	return strings.ToLower(e[i].name) > strings.ToLower(e[j].name)
}

func (e pageList) Swap(i, j int) {
	e[i], e[j] = e[j], e[i]
}

type LiboutFile interface {
	Write(path string) error
}

// Libout represents autogenerated output created by the compiler
type Libout interface {
	TestFile(packageName string) (LiboutFile, error)
	HTTPFile(packageName string) (LiboutFile, error)
	EnvFile(*BundleGroup) (LiboutFile, error)
}

type FilePathOpts struct {
	TestFile string
	HTTPFile string
	EnvFile  string
}

type BundleWriter interface {
	WriteLibout(files Libout, fOpts *FilePathOpts) error
	AcceptComponent(ctx context.Context, c srcpack.PackComponent, cacheOpts *webwrap.CacheDOMOpts) error
	AcceptComponents(ctx context.Context, comps []srcpack.PackComponent, cacheOpts *webwrap.CacheDOMOpts) error
}

type BundleGroup struct {
	*BundleGroupOpts

	pages            pageList
	pageMap          map[string]bool
	componentBodyMap map[string][]string
	wrapDocRender    map[string][]embedutils.FileReader
}

func (opts *BundleGroup) WriteLibout(files Libout, fOpts *FilePathOpts) error {
	fns := []func() (LiboutFile, string, error){
		func() (LiboutFile, string, error) {
			f, err := files.EnvFile(opts)

			return f, fOpts.EnvFile, err
		},
		func() (LiboutFile, string, error) {
			f, err := files.HTTPFile(opts.PackageName)

			return f, fOpts.HTTPFile, err
		},
		func() (LiboutFile, string, error) {
			f, err := files.TestFile(opts.PackageName)

			return f, fOpts.TestFile, err
		},
	}

	// @@todo(guy): concurrent this
	for _, fn := range fns {
		fs, path, err := fn()
		if err != nil {
			return err
		}

		err = fs.Write(path)
		if err != nil {
			return err
		}
	}

	return nil
}

// parseVersionKey parses the version key and converts it to a valid key
func parseVersionKey(k string) string {
	f := strings.ReplaceAll(k, ".", "_")
	return strings.ReplaceAll(f, "-", "")
}

// AcceptComponent collects the required DOM elements and applies it to the component body map
func (l *BundleGroup) AcceptComponent(ctx context.Context, c srcpack.PackComponent, cacheOpts *webwrap.CacheDOMOpts) error {
	if err := c.WebWrapper().VerifyRequirements(); err != nil {
		return err
	}

	v := parseVersionKey(c.WebWrapper().Version())
	if !l.pageMap[c.Name()] {
		l.pages = append(l.pages, &page{c.Name(), c.BundleKey(), v, c.OriginalFilePath(), c.IsStaticResource()})
		l.pageMap[c.Name()] = true
	}

	if l.componentBodyMap[v] == nil {
		l.componentBodyMap[v] = c.WebWrapper().RequiredBodyDOMElements(ctx, cacheOpts)
	}

	if l.wrapDocRender[v] == nil {
		l.wrapDocRender[v] = c.WebWrapper().HydrationFile()
	}

	return nil
}

// AcceptComponents collects the required DOM elements and applies it to the component body map
func (l *BundleGroup) AcceptComponents(ctx context.Context, comps []srcpack.PackComponent, cacheOpts *webwrap.CacheDOMOpts) error {
	for _, c := range comps {
		v := parseVersionKey(c.WebWrapper().Version())

		if !l.pageMap[c.Name()] {
			l.pages = append(l.pages, &page{c.Name(), c.BundleKey(), v, c.OriginalFilePath(), c.IsStaticResource()})
			l.pageMap[c.Name()] = true
		}

		if l.componentBodyMap[v] == nil {
			l.componentBodyMap[v] = c.WebWrapper().RequiredBodyDOMElements(ctx, cacheOpts)
		}

		// @@todo: to provide support for other language and/or frameworks, we will need to do analysis on the
		// requested language and pass it to the web wrapper.
		if l.wrapDocRender[v] == nil {
			l.wrapDocRender[v] = c.WebWrapper().HydrationFile()
		}
	}
	return nil
}

func New(opts *BundleGroupOpts) *BundleGroup {
	return &BundleGroup{
		BundleGroupOpts:  opts,
		pageMap:          make(map[string]bool),
		pages:            make([]*page, 0),
		componentBodyMap: make(map[string][]string),
		wrapDocRender:    make(map[string][]embedutils.FileReader),
	}
}
