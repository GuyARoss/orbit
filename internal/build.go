// Copyright (c) 2021 Guy A. Ross
// This source code is licensed under the GNU GPLv3 found in the
// license file in the root directory of this source tree.

package internal

import (
	"context"
	"fmt"
	"io/fs"

	"github.com/GuyARoss/orbit/internal/assets"
	"github.com/GuyARoss/orbit/internal/libout"
	"github.com/GuyARoss/orbit/internal/srcpack"
	"github.com/GuyARoss/orbit/pkg/fsutils"
	"github.com/GuyARoss/orbit/pkg/log"
	"github.com/GuyARoss/orbit/pkg/webwrap"
	"github.com/spf13/viper"
)

type BuildOpts struct {
	// PackageName is the name of the package that will be written to in the subdirectory of the "OutDir" option
	// this PackageName also modifies the code generator directly for source that requires package name modification.
	PackageName string
	OutDir      string
	// ApplicationDir is the directory that includes the components and pages as the primary children of the directory tree.
	ApplicationDir string
	// Mode is the underlying environment mode used to optimize specific environments
	// e.g "development" and "production"
	Mode string
	// NodeModulePath is the path of the node module directory
	NodeModulePath string
	// PublicDir is the path used for pointing to the base public html file.
	PublicPath string
	// RequiredDirs are directories that are required for the build commands file structure.
	// these directories get verified on initialization of the file structure.
	RequiredDirs []string
	// NoWrite disables the autogenerated package generation and writing to the file tree
	// this option should be used for commands that do not require the autogenerated packages.
	NoWrite bool
	// PriorityEntry is a page entry that will skip all other entries during the build process
	// this option is for SPAs, and will skip building all other pages.
	PriorityEntry string
}

func (opts *BuildOpts) FindAllPages() []string {
	if len(opts.PriorityEntry) > 0 {
		return []string{fmt.Sprintf("%s/%s", opts.ApplicationDir, opts.PriorityEntry)}
	}

	// TODO(pages): remove hardcode pages path
	return fsutils.DirFiles(fmt.Sprintf("%s/pages", opts.ApplicationDir))
}

func NewBuildOptsFromViper() *BuildOpts {
	return &BuildOpts{
		PackageName:    viper.GetString("package_name"),
		OutDir:         viper.GetString("out_dir"),
		Mode:           viper.GetString("mode"),
		NodeModulePath: viper.GetString("node_modules_dir"),
		PublicPath:     viper.GetString("public_path"),
		NoWrite:        len(viper.GetString("spa_entry_path")) > 0,
		PriorityEntry:  viper.GetString("spa_entry_path"),
		ApplicationDir: viper.GetString("app_dir"),
	}
}

func Build(opts *BuildOpts) (srcpack.PackedComponentList, error) {
	ats, err := assets.AssetKeys()
	if err != nil {
		return nil, err
	}

	s := &FileStructure{
		PackageName: opts.PackageName,
		OutDir:      opts.OutDir,
		Assets: []fs.DirEntry{
			ats.AssetEntry(assets.WebPackConfig),
			ats.AssetEntry(assets.SSRProtoFile),
			ats.AssetEntry(assets.JsWebPackConfig),
			ats.AssetEntry(assets.WebPackSWCConfig),
		},
		Mkdirs: opts.RequiredDirs,
	}

	if err = s.Make(); err != nil {
		return nil, err
	}

	pages := opts.FindAllPages()

	// attempts to read the env file for the cached bundle information
	c, err := CachedEnvFromFile(fmt.Sprintf("%s/%s/orb_env.go", opts.OutDir, opts.PackageName))
	if err != nil && !opts.NoWrite {
		return nil, err
	}

	packer := srcpack.NewDefaultPacker(log.NewDefaultLogger(), &srcpack.DefaultPackerOpts{
		WebDir:           opts.ApplicationDir,
		BundlerMode:      opts.Mode,
		NodeModuleDir:    opts.NodeModulePath,
		CachedBundleKeys: c,
	})

	components, err := packer.PackMany(pages)
	if err != nil {
		return nil, err
	}

	bg := libout.New(&libout.BundleGroupOpts{
		PackageName:   opts.PackageName,
		BaseBundleOut: ".orbit/dist",
		BundleMode:    opts.Mode,
		PublicDir:     opts.PublicPath,
	})

	if !opts.NoWrite {
		ctx := context.Background()
		ctx = context.WithValue(ctx, webwrap.BundlerID, opts.Mode)

		if err = bg.AcceptComponents(ctx, components, &webwrap.CacheDOMOpts{
			CacheDir:  ".orbit/dist",
			WebPrefix: "/p/",
		}); err != nil {
			return nil, err
		}

		liboutFiles := libout.NewGOLibout(
			ats.AssetKey(assets.Tests),
			ats.AssetKey(assets.PrimaryPackage),
		)

		if err = bg.WriteLibout(liboutFiles, &libout.FilePathOpts{
			TestFile: fmt.Sprintf("%s/%s/orb_test.go", opts.OutDir, opts.PackageName),
			EnvFile:  fmt.Sprintf("%s/%s/orb_env.go", opts.OutDir, opts.PackageName),
			HTTPFile: fmt.Sprintf("%s/%s/orb_http.go", opts.OutDir, opts.PackageName),
		}); err != nil {
			return nil, err
		}
	}

	return components, nil
}
